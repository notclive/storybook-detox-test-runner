import { mkdirSync, readFileSync, rmSync, writeFileSync } from 'fs'
import { basename, dirname, extname, join, relative } from 'path'
import { getStoryTitle, serverRequire } from 'storybook/internal/common'
import { loadCsf, type StaticStory } from 'storybook/internal/csf-tools'
import type { StoriesEntry, StorybookConfig } from 'storybook/internal/types'
import { findStoriesToTest as findCsfsToTest } from './find-stories-to-test'

export function generateTests ({
  projectRoot,
  storybookConfigDirectory,
  testDirectory
}: {
  projectRoot: string;
  storybookConfigDirectory: string;
  testDirectory: string;
}) {
  const csfPatterns = getCsfPatterns(storybookConfigDirectory)

  rmSync(testDirectory, { recursive: true, force: true })
  mkdirSync(testDirectory, { recursive: true })

  const csfsToTest = findCsfsToTest(
    csfPatterns,
    { projectRoot, storybookConfigDirectory }
  )

  for (const csfToTest of csfsToTest) {
    const code = readFileSync(csfToTest, { encoding: 'utf-8' })
    const storiesInCsf = parseCsf(code, csfToTest, csfPatterns, storybookConfigDirectory)
    const jestTest = generateJestTest(csfToTest, storiesInCsf)

    // make spec path unique by mirroring the CSF relative path under .detox-tests
    const relCsfPath = relative(projectRoot, csfToTest)
    const outDir = join(testDirectory, dirname(relCsfPath))
    mkdirSync(outDir, { recursive: true })

    const outFile = join(outDir, `${basename(csfToTest, extname(csfToTest))}.spec.js`)
    writeFileSync(outFile, jestTest)
  }

  return { csfsToTest }
}

function getCsfPatterns (configDir: string) {
  // Typescript config is not supported.
  const mainConfig = serverRequire(join(configDir, 'main')) as Partial<StorybookConfig> | undefined
  if (!mainConfig) {
    throw new Error(`Could not load main.js in ${configDir}.`)
  }
  if (!mainConfig.stories || mainConfig.stories.length === 0) {
    throw new Error(`Could not find stories in main.js in "${configDir}".`)
  }
  return mainConfig.stories as StoriesEntry[]
}

function parseCsf (code: string, csfFilePath: string, csfPatterns: StoriesEntry[], storybookConfigDirectory: string) {
  const csf = loadCsf(code, {
    fileName: csfFilePath,
    makeTitle (userTitle) {
      return getStoryTitle({
        storyFilePath: csfFilePath,
        configDir: storybookConfigDirectory,
        stories: csfPatterns,
        userTitle
      }) || 'unknown'
    }
  })
  const { _stories } = csf.parse()
  return _stories
}

function generateJestTest (csfFilePath: string, stories: Record<string, StaticStory>) {
  return `
    // This file is auto-generated by storybook-detox-test-runner.
    const story = require('${csfFilePath}')
    const channel = require('${join(__dirname, '..', 'channel.js')}')
    const detox = require('detox')

    beforeAll(async () => {
      await channel.routeFromDeviceToServer()
    })

    function testOrSkip (onlyOnOperatingSystems) {
      if (onlyOnOperatingSystems === undefined) {
        return test
      }
      return onlyOnOperatingSystems.includes(device.getPlatform()) ? test : test.skip
    }

    ${Object.entries(stories)
        .map(([variableName, story]) => generateTestForStory(variableName, story))
        .join('')}`
}

function generateTestForStory (variableName: string, story: StaticStory) {
  // use story.id as test name to avoid collisions like "Default"
  return `
    testOrSkip(story.${variableName}.detox?.onlyOnOperatingSystems)('${story.id}', async function () {
      await device.launchApp(story.${variableName}.detox?.launch)
      await channel.changeStory('${story.id}')
      await story.${variableName}.play?.({ detox })
    })\n\n`
}
